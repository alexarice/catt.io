#
#  cylinders.catt - playing with cylinder types
#

# Just need to figure out how we are going to deal
# with cylinders and what-have you.

let cyl1 {C : Cat} (x :: Arr C) : [ C ]
  = base x

let cyl2 {C : Cat} (x :: Arr C) : [ C ]
  = lid x

let cyl3 {C : Cat} (x :: Arr C) : [ base x => lid x ]
  = core x

# Change the syntax ....
let cyl4 {C : Cat} (x :: C) (y : C) (f : x => y) : [ Arr C ]
  = cyl x y f 

let cyl5 {C : Cat} (x :: Arr C) (y :: Arr C) (f :: x => y) : [ base x => base y ]
  = base f

let cyl6 {C : Cat} (x :: Arr C) (y :: Arr C) (f :: x => y) : [ lid x => lid y ]
  = lid f

let cyl6 {C : Cat} (x :: Arr C) (y :: Arr C) (f :: x => y)
  : [ comp (base f) (core y) =>
      comp (core x) (lid f) ]
  = core f

let cyl7 {C : Cat}
    (x0 :: C) (y0 :: C) (f0 :: x0 => y0)
    (x1 :: C) (y1 :: C) (f1 :: x1 => y1)
    (x_c :: x0 => x1)
    (y_c :: y0 => y1)
    (f_c :: `[ comp 1 0 1 ] f0 y_c => `[ comp 1 0 1 ] x_c f1)
  : [ cyl x0 x1 x_c => cyl y0 y1 y_c ]
  = cyl f0 f1 f_c 






