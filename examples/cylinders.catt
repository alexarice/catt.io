#
#  cylinders.catt - playing with cylinder types
#

#
#  Constructing cylinders
#

let cyl0 {C : Cat} (x :: C) (y :: C) (f :: x => y) : [ Arr C ]
  = cyl x y f 

let cyl1 {C : Cat}
    (xb :: C) (xl :: C) (xc :: xb => xl)
    (yb :: C) (yl :: C) (yc :: yb => yl)
    (fb :: xb => yb) (fl :: xl => yl)
    (fc :: ucomp [ 1 0 1 ] fb yc => ucomp [ 1 0 1 ] xc fl)
  : [ Arr C | cyl xb xl xc => cyl yb yl yc ]
  = cyl fb fl fc

let cyl2 {C : Cat}
    (xb :: C) (xl :: C) (xc :: xb => xl)
    (yb :: C) (yl :: C) (yc :: yb => yl)
    (fb :: xb => yb) (fl :: xl => yl)
    (fc :: ucomp [ 1 0 1 ] fb yc => ucomp [ 1 0 1 ] xc fl)
    (gb :: xb => yb) (gl :: xl => yl)
    (gc :: ucomp [ 1 0 1 ] gb yc => ucomp [ 1 0 1 ] xc gl)
    (ab :: fb => gb) (al :: fl => gl)
    (ac :: ucomp [ 2 1 2 ] (ucomp [ 2 0 1 ] ab yc) gc =>
           ucomp [ 2 1 2 ] fc (ucomp [ 1 0 2 ] xc al))
  : [ Arr C | cyl xb xl xc => cyl yb yl yc | cyl fb fl fc => cyl gb gl gc ]
  = cyl ab al ac

#
#  Destructing cylinders
#

let base0 {C : Cat} (x :: Arr C) : [ C ]
  = base x

let base1 {C : Cat} (x :: Arr C) (y :: Arr C) (f :: x => y) : [ base x => base y ]
  = base f

let base2 {C : Cat}
    (x :: Arr C)
    (y :: Arr C) (f :: x => y)
                 (g :: x => y) (a :: f => g)
  : [ base f => base g ]
  = base a 

let lid0 {C : Cat} (x :: Arr C) : [ C ]
  = lid x

let lid1 {C : Cat} (x :: Arr C) (y :: Arr C) (f :: x => y) : [ lid x => lid y ]
  = lid f

let lid2 {C : Cat}
    (x :: Arr C)
    (y :: Arr C) (f :: x => y)
                 (g :: x => y) (a :: f => g)
  : [ lid f => lid g ]
  = lid a 

let core0 {C : Cat} (x :: Arr C) : [ base x => lid x ]
  = core x

let core1 {C : Cat}
    (x :: Arr C)
    (y :: Arr C) (f :: x => y)
  : [ ucomp [ 1 0 1 ] (base f) (core y) =>
      ucomp [ 1 0 1 ] (core x) (lid f) ]
  = core f

let core2 {C : Cat}
    (x :: Arr C)
    (y :: Arr C) (f :: x => y)
                 (g :: x => y) (a :: f => g)
  : [ ucomp [ 2 1 2 ] (ucomp [ 2 0 1 ] (base a) (core y)) (core g) =>
      ucomp [ 2 1 2 ] (core f) (ucomp [ 1 0 2 ] (core x) (lid a)) ]
  = core a
  
let core3 {C : Cat}
    (x :: Arr C)
    (y :: Arr C) (f :: x => y)
                 (g :: x => y) (a :: f => g)
                               (b :: f => g) (m :: a => b)
  : [ ucomp [ 3 2 3 ] (ucomp [ 3 1 2 ] (ucomp [ 3 0 1 ] (base m) (core y)) (core g)) (core b) =>
      ucomp [ 3 2 3 ] (core a) (ucomp [ 2 1 3 ] (core f) (ucomp [ 1 0 3 ] (core x) (lid m))) ]
  = core m 
