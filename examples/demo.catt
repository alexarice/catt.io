#
#  demo.catt - new syntax demo and whatnot
#

# let identity {A : U} (a : A) : A = a
# let bad (A : U) (B : U) (a : A) (b : B) : B = a

# Some impredicative encodings
# let List : U -> U
#   = \A. (L : U) -> (A -> L -> L) -> L -> L
# let nil : (A : _) -> List A
#   = \A. \L. \cons. \nil. nil
# let cons : (A : U) -> A -> List A -> List A
#   = \A. \x. \xs. \L. \cons. \nil. cons x (xs _ cons nil)

# let cattest1 (C : Cat) : U = [ C ]
# let cattest2 (C : Cat) (x :: C) (y :: C) : Cat = x => y
# let cattest3 (C : Cat) (x :: C) (y :: C) : U = [ x => y ]
# let cattest4 (C : Cat) (x :: C) (y :: C)
#   (f :: x => y) (g :: x => y)
#   : Cat = f => g

coh id {C : Cat} (x :: C)
  : x => x

coh comp {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
  : x => z

# let twice {C : Cat} {x :: C} (f :: x => x) : [ x => x ]
#     = comp f f

# let precomp {C : Cat} {x :: C} {y :: C} {z :: C} (f :: x => y)
#   : [ y => z ] -> [ x => z ]
#   = comp f 

# let postcomp {C : Cat} {x :: C} {y :: C} {z :: C} (g :: y => z)
#   : [ x => y ] -> [ x => z ]
#   = \f. comp f g
  
coh unit_l {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
  : comp (id x) f => f

# Abbreviated syntax: 
# coh unit_l [ x(y,f) ]
#   : comp (id x) f => f 

coh unit_r {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
  : comp f (id y) => f
  
coh assoc {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
    {w :: C} (h :: z => w)
  : comp f (comp g h) =>
    comp (comp f g) h

# coh assoc [ x(y,f)(z,g)(w,h) ]
#   : comp f (comp g h) =>
#     comp (comp f g) h 
  
coh horiz {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
             {g :: x => y} (a :: f => g)
    {z :: C} {h :: y => z}
       	     {k :: y => z} (b :: h => k)
  : comp f h => comp g k 

# coh horiz [ x(y,f(g,a))(z,h(k,b)) ]
#   : comp f h => comp g k 

[ x(y,f(g,u)(h,v))(z,j) ]

coh vert {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
       	     {g :: x => y} (a :: f => g)
	     {h :: x => y} (b :: g => h)
  : f => h

# this shows that unification can automatically
# detect suspensions!
# let vert_alt {C : Cat}
#     {x :: C}
#     {y :: C} {f :: x => y}
#        	     {g :: x => y} (a :: f => g)
# 	     {h :: x => y} (b :: g => h)
#   : [ f => h ]
#   = comp a b


