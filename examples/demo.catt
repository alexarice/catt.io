#
#  demo.catt - new syntax demo and whatnot
#

# let id {A : U} (a : A) : A = a
# let bad (A : U) (B : U) (a : A) (b : B) : B = a

# let cattest1 (C : Cat) : U = [ C ]
# let cattest2 (C : Cat) (x :: C) (y :: C) : Cat = x => y
# let cattest3 (C : Cat) (x :: C) (y :: C) : U = [ x => y ]
# let cattest4 (C : Cat) (x :: C) (y :: C)
#   (f :: x => y) (g :: x => y)
#   : Cat = f => g


# Some impredicative encodings
# let List : U -> U
#   = \A. (L : U) -> (A -> L -> L) -> L -> L
# let nil : (A : _) -> List A
#   = \A. \L. \cons. \nil. nil
# let cons : (A : U) -> A -> List A -> List A
#   = \A. \x. \xs. \L. \cons. \nil. cons x (xs _ cons nil)

coh id {C : Cat}
    (x :: C)
  : x => x

coh comp {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
  : x => z

coh unit_l {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
  : comp (id x) f => f

coh unit_r {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
  : comp f (id y) => f
  
coh assoc {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
    {w :: C} (h :: z => w)
  : comp f (comp g h) =>
    comp (comp f g) h

coh horiz {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
             {g :: x => y} (a :: f => g)
    {z :: C} {h :: y => z}
       	     {k :: y => z} (b :: h => k)
  : comp f h => comp g k 
