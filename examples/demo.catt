#
#  demo.catt - new syntax demo and whatnot
#

coh id {C : Cat} (x :: C)
  : x => x

coh comp {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
  : x => z
  
coh assoc {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
    {w :: C} (h :: z => w)
  : comp f (comp g h) =>
    comp (comp f g) h

coh unit_l {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
  : comp (id x) f => f

coh unit_r {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
  : comp f (id y) => f

coh horiz {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
             {g :: x => y} (a :: f => g)
    {z :: C} {h :: y => z}
       	     {k :: y => z} (b :: h => k)
  : comp f h => comp g k 

coh vert {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
       	     {g :: x => y} (a :: f => g)
	     {h :: x => y} (b :: g => h)
  : f => h

# this shows that unification can automatically
# detect suspensions!
# let vert_alt {C : Cat}
#     {x :: C}
#     {y :: C} {f :: x => y}
#        	     {g :: x => y} (a :: f => g)
# 	     {h :: x => y} (b :: g => h)
#   : [ f => h ]
#   = comp a b

# let twice {C : Cat} {x :: C} (f :: x => x) : [ x => x ]
#     = comp f f

# let precomp {C : Cat} {x :: C} {y :: C} {z :: C} (f :: x => y)
#   : [ y => z ] -> [ x => z ]
#   = comp f 

# let postcomp {C : Cat} {x :: C} {y :: C} {z :: C} (g :: y => z)
#   : [ x => y ] -> [ x => z ]
#   = \f. comp f g
  
